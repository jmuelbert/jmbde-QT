/*!
    \contentspage{index.html}{Qbs}
    \page index.html
    \nextpage overview.html

    \title Qbs Manual

    \section1 Version \qbsversion

    \QBS is a tool that helps simplify the build process for
    developing projects across multiple platforms. \QBS can be used for any
    software project, regardless of programming language, toolkit, or libraries used.


    \note Please report bugs and suggestions to the
    \l{http://bugreports.qt.io/}{Qt Bug Tracker}.

    \list
       \li  \l{Introduction}
       \li  \l{Setup}
           \list
               \li  \l{Installing}
               \li  \l{Configuring}
               \li  \l{Managing Qt Versions}
           \endlist
       \li  \l{Usage}
           \list
               \li  \l{Language Introduction}
               \li  \l{Building Applications}
               \li  \l{Running Applications}
               \li  \l{Installing Files}
               \li  \l{Target Platforms}
               \li  \l{Using the Shell}
               \li  \l{Generators}
               \li  \l{Multiplexing}
               \li  \l{Custom Modules and Items}
           \endlist
       \li  \l{How-tos}
       \li  \l{Reference}
           \list
                \li \l{List of All Items}
                \list
                    \li \l{List of Language Items}
                    \li \l{List of Convenience Items}
                \endlist
                \li \l{List of Built-in Services}
                \li \l{Command-Line Interface}
                \li \l{List of Modules}
                \li \l{Command and JavaScriptCommand}
           \endlist

       \li  \l{Appendix A: Building Qbs}
       \li  \l{Appendix B: Migrating from Other Build Systems}
       \li  \l{Appendix C: Code Attributions}
    \endlist
*/


/*!
    \contentspage index.html
    \previouspage index.html
    \page overview.html
    \nextpage setup.html

    \title Introduction

    \QBS is a build automation tool designed to conveniently manage the build
    process of software projects across multiple platforms.

    \section1 Features

    \QBS provides the following benefits:

    \list
        \li Declarative paradigm
        \li Well-defined language
        \li Platform and programming language independence
        \li Correct and fast incremental builds
        \li Extensible architecture
        \li Easy integration to IDEs
    \endlist

    \section2 Declarative Paradigm

    When writing a project, it is important to describe the build tasks and
    dependencies between them, rather than the build order. It is difficult to
    determine the correct build order in complex projects, especially during
    parallel builds. The build tool should bear that burden, not the developer.

    With a declarative language, \QBS enables you to express intent rather than
    specifying single build steps. This provides the appropriate level of
    abstraction for a build system. For example, \e dependencies can be created
    between \e products, such that the target \e artifacts of the dependency
    can be used as input to the build \e rules in the context of the depending
    product. In addition, you can \e export dependencies and \e properties to
    other products.

    \QBS is modular with clean interfaces between modules. A \e module is a
    collection of properties and \e {language items} that are used for
    building a product if the product depends on the module. The properties
    that can be set for a module are used to control the behavior of the
    toolchain used to build the module.

    \QBS itself knows nothing about file types or extensions, and therefore all
    source files in a product are handled equally. However, you can assign
    \e {file tags} to an artifact to act as markers or to specify a file type.
    \QBS applies a rule to the source files of the project and chooses the
    ones that match the input file tags specified by the rule. It then creates
    artifacts in the build graph that have other filenames and file tags.

    Products and projects can contain \e probes that are run prior to building,
    for instance to locate dependent headers, libraries, and other files outside
    the project directory.

    \section2 Well-Defined Language

    \QBS projects are specified in a QML dialect. QML is a concise, easy to
    learn, and intuitive language that is used successfully in the Qt project.
    Its core is declarative, but it can be extended with JavaScript snippets
    for extra flexibility.

    \QBS builds applications based on the information in a project file. Each
    project file specifies one \l{Project}{project} that can contain
    several \l{Product}{products}. You specify the type of the product,
    such as an \e application, and the dependencies the product has on other
    products.

    The product type determines the set of \l{Rule}{rules} that \QBS
    applies to produce artifacts from input files. The input files can be
    divided into \l{Group}{groups} according to their type or purpose, for
    example. A group can also be used to attach \l{Properties}{properties}
    to products.

    The following is an example of a minimal project file that specifies the
    product type, application name, source file, and a dependency on the
    \l{cpp} module:

    \code
    import qbs

    Application {
        name: "helloworld"
        files: "main.cpp"
        Depends { name: "cpp" }
    }
    \endcode

    For more information, see \l{Language Introduction}.

    \section2 Platform and Programming Language Independence

    \QBS can be used for any software project, regardless of programming
    language, toolkit, or libraries used. \QBS has built-in support for
    building applications for Windows, Linux, macOS, Android, iOS, tvOS,
    watchOS, QNX, and FreeBSD, as well as for cross-compilation. It can be
    easily extended to support further platforms.

    Invoking \l{build}{qbs build} from the command line automatically builds the
    project for the current host platform using the best available toolchain and
    settings, unless a default profile is set. You can configure additional
    profiles for each toolchain you want to use and select the profile to use
    at build time.

    For example, to build applications for Android devices, you would need to
    set up a profile for the Android toolchain and select it when you build the
    application. If you name the profile \e Android, you would then enter the
    following command:

    \code
    qbs build profile:Android
    \endcode

    For more information, see \l{Building Applications}.

    Platform and programming language support is implemented as a set of
    \l{List of Modules}{modules} that your product depends on. In the language
    example above, the dependency on the \l{cpp} module determines
    that the C++ sources are compiled and linked into a binary.

    Alternatively, you could use the \l{CppApplication}
    convenience item that implies a dependency on the \l{cpp} module:

    \code
    CppApplication {
        name: "helloworld"
        files: "main.cpp"
    }
    \endcode

    Additionally, if the sources use Qt, you need a dependency to the
    \l{Qt.core} module, and so on.

    In addition to building projects, \QBS can install the build artifacts to
    a location from where they can be run on the desktop or on a device. \QBS
    modules can be used to create installers for the end users of the
    applications. For example, the \l{dmg} module contains
    properties and rules for building Apple Disk Images, which are typically
    used to distribute applications and installers on macOS. The
    \l{innosetup}, \l{nsis}, and \l{wix} modules contain properties and rules
    for building installers for Windows platforms.

    \section2 Correct and Fast Incremental Builds

    \QBS is an all-in-one tool that generates a build graph from a high-level
    project description (like qmake or CMake) and additionally undertakes the
    task of executing the commands in the low-level build graph (like make).

    \QBS automatically takes advantage of multi-processor and multi-core systems
    to achieve maximum build parallelization. By default, running \c qbs without
    any arguments is roughly equivalent to running \c {make -j<n>} where \c n is
    the number of CPU cores. Similarly, \QBS allows the number of concurrent
    jobs to be explicitly specified using its own \c -j option.

    \QBS has knowledge about the whole project, and therefore builds remain
    correct even when you build sub-projects, because \QBS ensures that all
    dependencies are built too. This virtually eliminates the need for clean
    builds.

    \QBS uses dynamic build graphs with build rules that can generate a variable
    number of files and that are executed only when needed. When figuring out
    which rules to execute, \QBS starts at the product type and then looks for
    a way to produce artifacts with matching file tags from source files, using
    a chain of rules that are connected by their respective input and output
    tags. For an example of how rules are applied when building products, see
    \l{Rules and Product Types}.

    The \QBS build rules can produce a variable number of outputs.
    If the input changes, only the required rules are applied at build time.
    If a rule is applied, all the dependent rules are applied as well, but only
    those. This feature ensures the correctness of the build graph after source
    code changes without having to re-configure the whole project.

    Changing properties that do not affect the build, because they are not used
    by rules, will not cause the project to be rebuilt. The use of properties is
    tracked. Generated artifacts that cease to exist are deleted to avoid
    picking outdated generated artifacts and indefinitely increasing the size of
    the build directory.

    Fast incremental builds are crucial for a fast edit-build-run cycle.
    Instead of retrieving the timestamps of generated files, \QBS uses the time
    stamps stored in the build graph. This is especially important on Windows,
    where file system operations are slow.

    If the project files were not changed, the build graph is loaded from disk.
    It is stored in a binary format that can be loaded much faster than the real
    project files. The project files are parsed only if they were changed.

    \section2 Extensible Architecture

    You can create your own custom \l{List of Modules}{modules} and
    \l{List of Language Items}{items} and make \QBS aware of them.

    You store the custom modules and items in a subdirectory of the project
    directory and specify the path to the subdirectory as a value of the
    \l{Project::}{qbsSearchPaths} property. For example, if the custom module is
    located at \c my-modules/modules/modulename/modulename.qbs, you would
    specify it in the project file as follows:

    \code
    Project {
        qbsSearchPaths: "my-modules"
    \endcode

    For more information, see \l{Custom Modules and Items}.

    \section2 IDE Integration

    \QBS can be used not only from the command line, but also in combination
    with an IDE, such as Qt Creator, Microsoft Visual Studio, or Xcode.
    Qt Creator directly supports \QBS projects. Visual Studio and Xcode users
    can use \QBS to generate Microsoft Visual Studio and Xcode projects.
    For more information, see \l {Generators}.

    \section3 Qt Creator

    \l{http://doc.qt.io/qtcreator/index.html}{Qt Creator} uses the same \QBS
    library as the \QBS command line tools. Therefore, it can retrieve all the
    information required to build a single file or project through a defined
    public API. Qt Creator provides accurate information about the build
    progress and displays a project tree that reflects the logical structure of
    the project, instead of presenting low-level information, such as the file
    system structure. Adding or removing source files keeps the existing project
    file structure intact.

    For more information about using \QBS to build projects from Qt Creator, see
    \l{http://doc.qt.io/qtcreator/creator-project-qbs.html}{Setting Up Qbs}.

    \section1 Build Process

    \image qbs-build-process.png

    The build process of a product starts by examining the \l{Product::}{type}
    property of the product. It contains a list of \e {file tags} that are
    similar to MIME types.

    The following example product contains one file tag, \e application:

    \code
    import qbs

    Product {
        Depends { name: "cpp" }
        type: ["application"]
        files: ["main.cpp", "class.cpp", "class.h"]
    }
    \endcode

    \QBS then searches through all \e rules available in the context, meaning
    rules that are defined in the project or those that are made available
    through the dependency on a module, such as the compiler and linker rules
    pulled in from the \c cpp dependency in the example.

    When \QBS finds a rule that produces one or more artifacts with the relevant
    file tag, it looks at the depencencies of that rule and finds out that it
    produces artifacts tagged \c obj. It then finds a rule that produces \c obj
    artifacts that takes \c .cpp artifacts as input.

    \code
    import qbs
    Module {
        // ...
        Rule {
            inputs {"cpp"]
            Artifact [
                filePath: input.fileName + ".o"
                fileTags: {"obj"]
            }
            prepare: [
                // g++ -c main.cpp -o main.o ...
            }
        }
        //...
    }
    \endcode

    There is no rule in the current context that produces \c .cpp files, but
    we have defined \c .cpp files as inputs for the product. When we added a
    dependency on the \l{cpp} module, that dependency also pulled in another \QBS
    primitive called the \l{FileTagger}{file tagger}. The file tagger
    looked for files matching the pattern \c *.cpp, and then applied the \c cpp
    tag to those input files:

    \code
    Module {
        // ...
        FileTagger {
            patterns: "*.cpp"
            fileTags: ["cpp"]
        }
        //...
    }
    \endcode

    Since the \c .cpp files are input files, they by definition have no other
    dependencies, and we can go back the opposite way in the tree starting with
    the compiler rule described above.

    This design works well for generated files. The \c .cpp artifacts could come
    from another rule that produced them by processing some other input, either
    instead of or in addition to the raw files listed in the product.

    The compiler rule will be invoked twice, once for each \c .cpp file,
    producing a separate object file for each one. Then the linker rule will be
    invoked. Its \c multiplex property is set to \c true, which means that
    instead of producing one output per input and invoking the rule multiple
    times, all input will be collected before invoking the rule only once to
    produce the final application object.

    The standard versus multiplex rules map well to the compiler and linker
    processes. The compiler takes one input file to produce one output file,
    whereas the linker takes multiple input files to produce one output file.

    Finally, after the linker rule has been invoked, it produces an artifact
    tagged \c application. Because the product's type property did not contain
    other file tags, the build process is now complete.
*/
